# 辗转相除法求最大公约数
求最大公约数的一个有效方法是辗转相除法
其思想是`两个数的最大公约数，等于较小的数和两个数之差的最大公约数`
![](https://upload.wikimedia.org/wikipedia/commons/e/e2/Euclidean_algorithm_252_105_animation_flipped.gif)

这个辗转相除法又叫欧几里得算法，是很古老的算法，有很多个实现版本，包括除法版本，减法版本等。
其实我一开始想自己实现的时候，是想用一个变量保存较大的值，另一个变量保存较小的值，然后一直大数减去小数，直到最后减到结果为0。
然而真正的实现确实让我有点惊讶，并没有用这样的保存方式。标准的实现给出的代码如下

```c++
  if(a > b)
  {
    a = a - b;
  }
  else
  {
    b = b - a;
  }
```

其实这是相当领会精神的写法，为何？
很简答，辗转相除，其减法版本其实是为了找到最后a和b相等的值，这个值就是最大公约数，上面的写法恰好体现了这一精神，不管a和b谁比谁大，都要继续相减，那么不相减的条件是什么？不就是a等于b么，不就是最后的公约数的值么？这里其实就像是夹逼准则，不管是a还是b，都在向他们的最大公约数靠近，最后停靠在最大公约数上。

同样，除法版本，只不过是把可能的连续的减法偷懒一下，一步登天写为取余运算而已
但是，如果让我来写，我会先判断谁大谁小，因为我肯定是希望大数对小数取余啊，这样一旦取余结果为0，那么就找到了最大公约数，反之，若是个小数对大数取余，那么结果肯定不为0，岂不是麻烦？
然而，标准版本又一次让我认识到了自己的浅薄。

  ```c++
  int temp = 0;
  while(b)
  {
    temp = b;
    b = a % b;
    a = temp;
  }
  ```
  
  没有判断大小！
  这也是一个取余运算的奇妙之处，我们假设a比b小，运算一次之后我们会发现，a和b交换了值了，就又满足了我们需要的a大于b的要求，又可以继续取余了。其实在这里，a保存的是上上次的取余结果，b保存的是上次的取余结果，我们通过代码里的操作就能更新b和a，最终使b为0，然后a又成为了上次的取余结果，返回a（其实是上一个b），就是我们要的结果。
* [参考资料-维基百科-辗转相除法](https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95#.E8.AE.A1.E7.AE.97.E6.9C.BA.E5.AE.9E.E7.8E.B0)
